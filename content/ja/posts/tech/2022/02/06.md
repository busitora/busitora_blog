---
author: "Hugo Authors"
title: "プログラミングTypeScriptのメモ"
date: 2022-02-06
description: "プログラミングTypeScriptのメモ"
draft: false
hideToc: false
enableToc: true
enableTocContent: false
author: ブシトラ
authorEmoji: 🐯
tags:
- typescript
- oreilly
image: typescript/oreilly-typescript.jpg
---

そろそろ体系的に学ぶ必要のあるTypeScriptのメモ
ORELLYのTypeScriptを読むので、雑にメモしてく。

## 1章 イントロダクション

型安全性 → 型を使って、プログラムが不正なことをしないように防ぐこと

## 2章 TypeScript全体像

TypeScriptが独特なのは、バイトコードへと直接コンパイルする代わりに、なんと JavaScriptコードへとコンパイルする

TypeScriptコンパイラー(TSC)がよしなに抽象構文木(AST:abstract syntax tree)してくれる

大抵型推論があるので、明示的にアノテーションしなくてもOKな場合も多い。

コンパイル時にいチェックしてくれるのは神。
Jsだと実行時まで気づかない。。

## 3章 型について

型アノテーション(type annotation:明示的な型の指定)

anyはゴッドファーザー。
unknownは推論はしない。型を比較はできる。
もし、その特定の型としたことを想定したいのなら、`typeof` 等で分岐処理する必要がある

```ts
let a: unknown = 30
let b = a === 123
let c = a + 10
if (typeof a === 'number') {
let d = a + 10 // number }
```

明示的 → 実際に代入
推論 → 型に予測してもらう
基本的には推論でいい。

リテラル型 → ただ1つの値を表し、それ以外の値は受け入れない型
constを使うと再代入ができないのでリテラル型になる

```ts
let a = true // boolean
var b = false // boolean
const c = true // true
let d: boolean = true // boolean
let e: true = true // true
let f: true = false // エラー TS2322: 型 'false' を型 'true' に // 割り当てることはできません。
```

オブジェクトリテラル型とインデックスシグネチャについてはまた復習する

```
・オブジェクトリテラル({})は、オブジェクトの型を即席で定義するために用いられる。
・インデックスシグネチャ([key: T]: U)は、オブジェクトが、複数のkey(型T)を含む可能性があり値はU型になることを示している。
```

### 3.2.9 型alias

型エイリアスを使うかどうかを決めるときには、ある値に名前を付けて独立した変数にするかどうかを決めるときと同様の判断に従う

### 3.2.11 タプル

```ts
// [名前, 名字, 生まれ年]のタプル
let b: [string, string, number] = ['malcolm', 'gladwell', 1963]

// 鉄道運賃の配列。方向によって異なる場合があります
let trainFares: [number, number?][] = [
[3.75], [8.25, 7.70], [10.50]
]
// これは次のものと同等です
let moreTrainFares: ([number] | [number, number])[] = [
// ... ]
```
タプル型は不均一なリストを安全にコード化するだけでなく、それが型付けするリストの長さを限定する。これらの機能により、
従来のシンプルな配列よりもはるかに大きな安全が得られる

### 3.2.12 null undefined void never

undefinedは、あるものがまだ定義されていないことを意味し、nullは、値が欠如していることを意味します

   型   | 意味
--------|------
null | 値の欠如
void | return文を持たない関数の戻り値
undefined | 値がまだ割り当てられていない変数
never | 決して戻ることのない関数の戻り値

## 4章 関数


### 4-1 関数の宣言と呼び出し

JSの関数定義方法は5つある

```ts

function greet(name: string) {
  return 'hello' + name
}
// 名前付き関数


let greet2 = function(name: string) {
  return 'hello' + name
}
// 関数式

let greet3 = (name: string) => {
  return 'hello' + name
}
// アロー関数式

let greet4 = (name: string) => 'hello' + name
// アロー関数式省略

let greet5 = new Function('name', 'return "hello " + name')
// 関数コンストラクタ (使っちゃ駄目)

```
### 4.1.1 オプションパラメータとデフォルトパラメータ

オプションパラメータ → userId?
デフォルトパラメータ → userId = "not assigned in"

デフォルトパラメータを使うほうがよさげ

### 4.1.2 レストパラメータ

可変長引数のこと

...numbers みたいなやつ

### 4.1.3 call apply bind

呼び出し方のやつ。さらっとしか見てない。
あんま使うイメージない

### 4.1.4 thisの型付け

関数でthisを使う場合は、期待するthisの型を、最初のパラメータとして宣言すればいいっぽい
### 4.1.5 ジェネレーター

https://typescript-jp.gitbook.io/deep-dive/future-javascript/generators

遅延評価?
あまり使ったことなかった
### 4.1.6 イテレーター

イテレーターはジェネレータの裏返し。ジェネレーターが一連の値を生成するのに対し、イテレーターは
それを利用する。

```ts
let numbers = {
  *[Symbol.iterator]() {
    for (let n = 1; n <= 10; n++) {
      yield n;
    }
  },
};
```
わからん。。

### 4.1.7 呼び出しシグネチャ

```ts
type Log = (message: string, userId?: string) => void
let log: Log = (
  message,
  userId = 'Not signed in'
) => {
  let time = new Date().toISOString()
   console.log(time, message, userId) }
```

### 4.1.8 文脈的型付

### 4.1.9 オーバーロードされた関数の型

後で読む

### 4.2 ポリモーフィズム

ジェネリクス型の話。
ここむずいんよなあぁ。
[【TypeScript】Generics(ジェネリックス)を理解する](https://qiita.com/k-penguin-sato/items/9baa959e8919157afcd4)

↑上記記事わかりやすい。
要するに、関数の中でおなじ型が入るなら、<number> <string> として <T> とできるイメージか。

### 4.2.3 ジェネリックの型推論

### 4.2.4 ジェネリック型エイリアス

### 4.2.5 制限付きポリモーフィズム

### 4.2.5.1 複数の制約を持つ制限付きポリモーフィズム

ジェネリクスの部分は後で書く。
### 4.3 型駆動開発

まず型シグネチャで概略を記述し、その後で値を埋め込むプログラミングのスタイル

```ts
function map<T, U>(array: T[], f: (item: T) => U): U[]
```

これまでmapを見たことがなかったとしてもmapが何をするかについてある程度は直観的にわかるはずです。つまり、Tの配列と、Tから Uへとマッピングする関数を取り、Uの配列を返すということです。それを知るために、その関数の実装を見る必要はありません!

↑ 直感的にまだ分かるようにはなっていないが、型の重要さは分かる。

## 5章 クラスとインターフェイス

チェスを例にオブジェクト指向

publicとprivateはRubyにもあるので省略。
protected → このクラスとサブクラスのインスタンスからアクセス可能。
