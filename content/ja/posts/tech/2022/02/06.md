---
author: "Hugo Authors"
title: "プログラミングTypeScriptのメモ"
date: 2022-02-06
description: "プログラミングTypeScriptのメモ"
draft: false
hideToc: false
enableToc: true
enableTocContent: false
author: ブシトラ
authorEmoji: 🐯
tags:
- typescript
- oreilly
image: typescript/oreilly-typescript.jpg
---

そろそろ体系的に学ぶ必要のあるTypeScriptのメモ
ORELLYのTypeScriptを読むので、雑にメモしてく。

## 1章 イントロダクション

型安全性 → 型を使って、プログラムが不正なことをしないように防ぐこと

## 2章 TypeScript全体像

TypeScriptが独特なのは、バイトコードへと直接コンパイルする代わりに、なんと JavaScriptコードへとコンパイルする

TypeScriptコンパイラー(TSC)がよしなに抽象構文木(AST:abstract syntax tree)してくれる

大抵型推論があるので、明示的にアノテーションしなくてもOKな場合も多い。

コンパイル時にいチェックしてくれるのは神。
Jsだと実行時まで気づかない。。

## 3章 型について

型アノテーション(type annotation:明示的な型の指定)

anyはゴッドファーザー。
unknownは推論はしない。型を比較はできる。
もし、その特定の型としたことを想定したいのなら、`typeof` 等で分岐処理する必要がある

```ts
let a: unknown = 30
let b = a === 123
let c = a + 10
if (typeof a === 'number') {
let d = a + 10 // number }
```

明示的 → 実際に代入
推論 → 型に予測してもらう
基本的には推論でいい。

リテラル型 → ただ1つの値を表し、それ以外の値は受け入れない型
constを使うと再代入ができないのでリテラル型になる

```ts
let a = true // boolean
var b = false // boolean
const c = true // true
let d: boolean = true // boolean
let e: true = true // true
let f: true = false // エラー TS2322: 型 'false' を型 'true' に // 割り当てることはできません。
```

オブジェクトリテラル型とインデックスシグネチャについてはまた復習する

```
・オブジェクトリテラル({})は、オブジェクトの型を即席で定義するために用いられる。
・インデックスシグネチャ([key: T]: U)は、オブジェクトが、複数のkey(型T)を含む可能性があり値はU型になることを示している。
```

### 3.2.9 型alias

型エイリアスを使うかどうかを決めるときには、ある値に名前を付けて独立した変数にするかどうかを決めるときと同様の判断に従う

### 3.2.11 タプル

```ts
// [名前, 名字, 生まれ年]のタプル
let b: [string, string, number] = ['malcolm', 'gladwell', 1963]

// 鉄道運賃の配列。方向によって異なる場合があります
let trainFares: [number, number?][] = [
[3.75], [8.25, 7.70], [10.50]
]
// これは次のものと同等です
let moreTrainFares: ([number] | [number, number])[] = [
// ... ]
```
タプル型は不均一なリストを安全にコード化するだけでなく、それが型付けするリストの長さを限定する。これらの機能により、
従来のシンプルな配列よりもはるかに大きな安全が得られる

### 3.2.12 null undefined void never

undefinedは、あるものがまだ定義されていないことを意味し、nullは、値が欠如していることを意味します

   型   | 意味
--------|------
null | 値の欠如
void | return文を持たない関数の戻り値
undefined | 値がまだ割り当てられていない変数
never | 決して戻ることのない関数の戻り値
